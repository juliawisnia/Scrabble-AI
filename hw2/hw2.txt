PROBLEM 1
(a) The README.md file is tracked and UNMODIFIED after performing these operations, because git knows about the file since it was just cloned from the repo, but we haven't made any edits to it yet.

(b) README.md is now tracked and MODIFIED, because it has been edited, and 
fun_problem.txt is not tracked and UNMODIFIED, because it was created in our local directory, and git has no way to know about the file yet.

(c) Both of these files are now STAGED, because git knows about both of them.

(d) Both files are now UNSTAGED/MODIFIED, because even though they were previously committed, they have been changed.

(e) README.md and fun_problem.txt are both STAGED now, however, the contents
of fun_problem.txt are what they were after the last commit to git because
git --checkout <file> un-dos the changes since the last commit, so the file 
is still empty.

(f) README.md is now STAGED and UNSTAGED/MODIFIED at the same time, because
git add stages a file exactly as it was when you ran the command, even if
you edit it after the add. In order to move the edited file into git now,
we would have to do another git add for the same file.

PROBLEM 3
1. The best data type would be a MAP with int keys for the zip codes, and 
another MAP within that of values. This would allow someone to access, for 
example, in the zip code 90089 (key to the first map), how many women (string 
key to the second map) voted for the Democratic party. However, the specificity
of the map can get deeper and deeper the more maps are stored within. For 
example, if you added another map to the values within the MAP of values, you 
could access how many women voted for the Democratic or Republican party, and 
so on.

2. The best data type for this would be a SET of strings. This would easily allow
the programmer to add more students names to the set, and since order doesn't 
matter, it would be quick. It also would be easy to find out which students had 
solved the problem with the bool contains function.

3. The best data type would be a LIST of strings sorted by their pokedex index. 
Because the list does not have to contain the pokedex index, as long as the list 
remains sorted, which is made possibly by the insert(position, value) 
functionality of a list, it would be easy to look up a Pokemon by its index.

4. The best data type would be a MAP with string keys, and this string would 
include the movie title, and year it was released formatted as one string. It 
could also have a value type of string so that it could return written reviews, 
as well as the percentages and scorings the movie recieved.Once again, the 
specificity could be deeper by adding more MAPS to the values, which maybe could 
specify the type of review you wanted to bring up.

PROBLEM 4
The linked list returned by funcA is the list 5, 4, 3, 2, 1, so what this
program is doing is reversing the linked list put in. When I trace through the
program, I see that funcA is running through the linked list, being recursively
called until out (funcA(in->next)) is pointing to the last element in the 
linked list, so in is pointing to the second to last element. After this, funcA
will return in, and start calling funcB. Tracing through funcB, I see that on
the first call, it will return in2->next=in1, so instead of the last element's 
next pointer pointing to NULL, it will point to the element before it. Once this
happens, the if statement will be triggered, calling funcB recursively, and keep
flipping each element's pointers to point to the element before it. Once this 
recursion completes, it will return to funcA, set the final (which used to be
the first) element's next pointer to NULL, and finally return out, which is now
pointing to the beginning of the linked list, so pointing to the new first
element, which used to be the last.
# CS 104 Student Repository

- **Name**: Julia Wisnia
- **USC ID**: 2096592657
- **Email**: wisnia@usc.edu

PROBLEM 2
(a):
enqueue(1) stack1: 1 is on the top
			stack2: empty

enqueue(2): stack 1: contains 1, 2, top is 2
			stack2: empty

dequeue(): stack 1: empty
			stack2: contains 2, 1, top is 1

enqueue(3): stack 1: 3 is on top
			stack2: contains 2, 1, top is 1

enqueue(4): stack1: contains 3, 4, top is 4
			stack2: contains 2, 1, top is 1

dequeue(): stack 1: contains 3, 4, top is 4
			stack2: 2 is on the top

enqueue(5): stack1: contains 3, 4, 5, top is 5
			stack2: 2 is on the top

enqueue(6): stack1: contains 3, 4, 5, 6, top is 6
			stack2: 2 is on the top
(b): enqueue(x) takes theta(1) time, because you are
		adding to the front of the list
		dequeue(x) takes theta(n) time, because you have to
		pop n items, then push n items, which would be 2n,
		so it becomes theta(n).
(c): enqueue(x) still takes theta(1) time, but dequeue(x)
		takes theta(n^2) time, because to pop n elements when
		pop() takes theta(n) would be n^2 time, then to push
		would also be n^2 time, and n^2+n^2 becomes theta(n^2).

PROBLEM 3
(a) First, we look at the inner 'for' loop
	// for (int j = 1; j < n; j *= 2) //
	Each time this loop runs, the problem is being halved,
	or getting 2 times smaller, so this loop executes in 
	log2n (log base 2 n) time, or theta(log2n). 

	Next, we move to the 'if' statement
	// if (A[i] == 0) //
	Because there are no constraints on A, we can assume that
	the worst case runtime of this is when the if statement
	triggers everytime, so we now move onto the outer 'for' loop

	// for (int i = 0; i < n; i ++) //
	This will run in theta(n) time, because that is how many
	times the statement will execute.

	Now, we have to sum the two for loops run times. The summation
	is adding log2n 'n' times to get the full runtime, which is
	nlog2n, which we can simplify to the final runtime, 
	theta(nlogn).

(b) First, we look at the inner 'for' loop
	// for (int k = 1; k < n; k *= 2) //
	Just as in the last problem, each time this loop runs, the
	problem is being halved, or getting 2 times smaller, so this
	loop executes in log2n time, or theta(log2n).

	Next, we look at the 'if' statement
	// if (j % i == 0) //
	To solve this part, we must look at the nested 'for' loops.
	We see that j starts off equal to i each time, and runs to
	n just like the outer 'for' loop. We can start off by looking
	at a case by case level. Let's say n=10. This if statement
	will trigger:
		9 times for i=1
		4 times for i=2
		3 times for i=3
		2 times for i=4
		1 time for i>=5 && i<=9
	We see that it is triggering (n-i)/i times as it gets larger
	and larger, so we can generalize this to n/i. Now, we do the
	summation of n/i from i=0 to n to account for the j 'for' loop,
	and from here we get a run time of nlogn for this. So, for
	the j and k for loops, we now have a run time of nlog^2n.

	Next, we look at the final outer 'for' loop, which simply runs
	from 0 to n, meaning in n time. When we sum this with the inner
	loops, we get that the entire runtime is theta(n^2*log^2n).

(c) First, we look at the inner-most for loop
	// for (int j = 0; j < size; j++) //
	From the above 'if' statment, we see that size=i, so j is running
	in theta(i) time. 

	Now, we look at the 'if' statement. We see that it only triggers
	when i=size, which occurs n/10 times, because size is being
	incremented by 10 each for loop. 

	So, we finally look at the outer 'for' loop, and from the 'if' 
	statement, know that this will have linear run time everytime the
	if statment does not trigger, so will only run in theta(i) time
	n/10 times. So, we can do the summation from i=0 to n of i,
	which becomes n^2. So, the final runtime is theta(n^2).

(d) First, we look at the inner-most for loop
	// for (int j = 0; j < size; j++) //
	From the above 'if' statment, we see that size=i, so j is running
	in theta(i) time. 

	Now, we look at the 'if' statement. We see that it only triggers
	when i=size, and size is being doubled everytime. This means that
	the problem is being doubled each time, which means that it will
	run logn times.

	So, we finally look at the outer 'for' loop, and from the 'if' 
	statement, know that this will have linear run time everytime the
	if statment does not trigger, so will only run in theta(i) time
	logn times. So, we can do the summation from i=0 to n of i,
	which becomes nlogn. So, the final runtime is theta(nlogn).